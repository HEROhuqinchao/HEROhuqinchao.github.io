[{"title":"Xcode编写Swift FrameWork","path":"post/546191697/","text":"iOS FrameWork 制作一 创建 FrameWork 工程运行 XCode -&gt; Cocoa Touch Framework -&gt; 取个名, 语言选择 Swift -&gt; 创建成功 二 基本设置 build setting -&gt; Mach-O Type -&gt; Dyanmic Library build setting -&gt; Build Active Architecture Only -&gt; NO build setting -&gt; Dead Code Stripping -&gt; NO build 环境设置为 release 三 编写内容代码文件 删除自动生成的 project.h 头文件 写入自己SDK内容代码 四 设置开放文件 文件暴露 -&gt; 将开放文件放入 build phases -&gt; Headers -&gt; Public 中 方法暴露 -&gt; 将方法前加入 public 字段 适用于 OC 项目 还需添加 @objc 字段 五 编译运行Products 文件夹下使用 六 合并包 将生成的真机包和模拟器包放入自定义文件夹中 使用终端 命令行 lipo -info 查看 包的架构如下显示：（示例为谷歌webrtc文件）******@Mac-mini ~ % lipo -info /Users/******/Documents/文稿\\ -\\ ***的Mac\\ mini/WebRTCSDK/bak/WebRTC.framework/WebRTCArchitectures in the fat file: /Users/huqinchao/Documents/文稿 - ***的Mac mini/WebRTCSDK/bak/WebRTC.framework/WebRTC are: armv7 x86_64 i386 arm64 ******@Mac-mini ~ % Xcode 新版会生成两个含有相同架构的framework 需要自行剔除分解 arm64, x86_64, i386, armv7 架构 命令如下：cd （自定义文件夹）mkdir ./bakcp -r XXXX.framework ./baklipo XXXX.framework/XXXX -thin armv7 -output XXXX_armv7lipo XXXX.framework/XXXX -thin arm64 -output XXXX_arm64lipo XXXX.framework/XXXX -thin x86_64 -output XXXX_x86_64lipo XXXX.framework/XXXX -thin i386 -output XXXX_i386lipo -create XXXX_armv7 XXXX_arm64 -output XXXX_1 ——&gt;真机版本剔除X86_64/i386lipo -create XXXX_x86_64 XXXX_i386 -output XXXX _2 ——&gt;模拟器版本剔除arm64lipo -create XXXX _2 XXXX _2 -output XXXX ——&gt;合并真机模拟器包 mv XXXX XXXX.framework/ ——&gt;移动到 .framework/ 文件夹内"},{"title":"Xcode 11 以上不显示Products 解决办法","path":"post/1302214085/","text":"XcodeXcode11+ ‘Per-configuration Build Products Path’ (最终文件路径) 没了 方式一Build Settings -&gt; 点击 ➕ 添加 -&gt; User-Defined 添加一行 Setting 自定义文件路径 CONFIGURATION_BUILD_DIR /Users/¥¥¥/Desktop/ 方式二打开项目 找到目标 项目名称.xcodeproj 右键点击显示包内容 -&gt; 打开project.pbxproj文件 -&gt; 全局搜索 productRefGroup关键字 找到如下显示内容 ： mainGroup = 33F5229D27339ED90048642D;productRefGroup = 33F522A727339ED90048642D /* Products */; 将上面 mainGroup 对应的值复制给 productRefGroup 的值 如下 ： mainGroup = 33F5229D27339ED90048642D;productRefGroup = 33F5229D27339ED90048642D /* Products */ 保存文件 此刻Xcode 就自动加载出来 Products 文件夹了"},{"title":"WebRTC使用","path":"post/2123500015/","text":"webrtc-mirrorWebRTC国内加速镜像 https://github.com/webrtc-mirror/mirror 项目背景在进行WebRTC开发的时候经常需要编译WebRTC，但由于WebRTC依赖较多（十几个G）， 而且大多数内容需要翻墙。 我们尝试了多种加速编译的方法，最终找到一个对WebRTC代码没有任何侵入的镜像方案。相信行业内的很多人都体验过WebRTC编译的痛苦，尤其是新接触WebRTC的人，我们决定提供这个WebRTC镜像的方案。快乐自己造福大家。 原理WebRTC的依赖主要分为三类: 1，放在git中的代码，这部分大概有三十多个仓库， gcient sync 会把这些git仓库的历史记录都拉下来，所以有的厂库会非常大，这些代码大都在google code上， 在镜像的时候我们把这些git代码同步到了gitlab， 之所以放到gitlab上是因为github上对仓库大小会做限制，导致有些代码同步不成功。这些依赖会10分钟同步一次，保持跟google code上代码仓库保持一致。 2，cipd的模块代码， 这部分代码放在appspot.com上面，这部分代码不好做镜像，可以通过采用http代理的方式来进行下载。 3，google storage上的依赖， google storage上的内容非常庞大， 不好做镜像， 可以通过采用http代理的方式进行下载。 在同步WebRTC的依赖过程中，git中的代码会从gitlab相对应的仓库中拉取， 不好镜像的部分我们提供了http代理进行下载。 镜像说明 对WebRTC源码不做任何修改 每十分钟和官方代码同步一次 感谢 我们的镜像方案参考了声网的方案，具体可以看 https://rtcdeveloper.com/t/topic/14914 感谢gitlab承载了部分webrtc代码和第三方依赖的代码，https://gitlab.com/webrtc-mirror 编译步骤替换git仓库地址git config --global url.https://gitlab.com/webrtc-mirror/webrtc.git.insteadOf https://chromium.googlesource.com/external/webrtc.gitgit config --global url.https://gitlab.com/webrtc-mirror/base.git.insteadOf https://chromium.googlesource.com/chromium/src/basegit config --global url.https://gitlab.com/webrtc-mirror/build.git.insteadOf https://chromium.googlesource.com/chromium/src/buildgit config --global url.https://gitlab.com/webrtc-mirror/buildtools.git.insteadOf https://chromium.googlesource.com/chromium/src/buildtoolsgit config --global url.https://gitlab.com/webrtc-mirror/gradle.git.insteadOf https://chromium.googlesource.com/external/github.com/gradle/gradle.gitgit config --global url.https://gitlab.com/webrtc-mirror/ios.git.insteadOf https://chromium.googlesource.com/chromium/src/ios.gitgit config --global url.https://gitlab.com/webrtc-mirror/testing.git.insteadOf https://chromium.googlesource.com/chromium/src/testinggit config --global url.https://gitlab.com/webrtc-mirror/third_party.git.insteadOf https://chromium.googlesource.com/chromium/src/third_partygit config --global url.https://gitlab.com/webrtc-mirror/clang-format.git.insteadOf https://chromium.googlesource.com/chromium/llvm-project/cfe/tools/clang-format.gitgit config --global url.https://gitlab.com/webrtc-mirror/libcxx.git.insteadOf https://chromium.googlesource.com/chromium/llvm-project/libcxx.gitgit config --global url.https://gitlab.com/webrtc-mirror/libcxxabi.git.insteadOf https://chromium.googlesource.com/chromium/llvm-project/libcxxabi.gitgit config --global url.https://gitlab.com/webrtc-mirror/libunwind.git.insteadOf https://chromium.googlesource.com/external/llvm.org/libunwind.gitgit config --global url.https://gitlab.com/webrtc-mirror/android_ndk.git.insteadOf https://chromium.googlesource.com/android_ndk.gitgit config --global url.https://gitlab.com/webrtc-mirror/android_tools.git.insteadOf https://chromium.googlesource.com/android_tools.gitgit config --global url.https://gitlab.com/webrtc-mirror/auto.git.insteadOf https://chromium.googlesource.com/external/github.com/google/auto.gitgit config --global url.https://gitlab.com/webrtc-mirror/catapult.git.insteadOf https://chromium.googlesource.com/catapult.gitgit config --global url.https://gitlab.com/webrtc-mirror/compact_enc_det.git.insteadOf https://chromium.googlesource.com/external/github.com/google/compact_enc_det.gitgit config --global url.https://gitlab.com/webrtc-mirror/colorama.git.insteadOf https://chromium.googlesource.com/external/colorama.gitgit config --global url.https://gitlab.com/webrtc-mirror/depot_tools.git.insteadOf https://chromium.googlesource.com/chromium/tools/depot_tools.gitgit config --global url.https://gitlab.com/webrtc-mirror/errorprone.git.insteadOf https://chromium.googlesource.com/chromium/third_party/errorprone.gitgit config --global url.https://gitlab.com/webrtc-mirror/ffmpeg.git.insteadOf https://chromium.googlesource.com/chromium/third_party/ffmpeg.gitgit config --global url.https://gitlab.com/webrtc-mirror/findbugs.git.insteadOf https://chromium.googlesource.com/chromium/deps/findbugs.gitgit config --global url.https://gitlab.com/webrtc-mirror/freetype2.git.insteadOf https://chromium.googlesource.com/chromium/src/third_party/freetype2.gitgit config --global url.https://gitlab.com/webrtc-mirror/harfbuzz.git.insteadOf https://chromium.googlesource.com/external/github.com/harfbuzz/harfbuzz.gitgit config --global url.https://gitlab.com/webrtc-mirror/gtest-parallel.git.insteadOf https://chromium.googlesource.com/external/github.com/google/gtest-parallelgit config --global url.https://gitlab.com/webrtc-mirror/googletest.git.insteadOf https://chromium.googlesource.com/external/github.com/google/googletest.gitgit config --global url.https://gitlab.com/webrtc-mirror/icu.git.insteadOf https://chromium.googlesource.com/chromium/deps/icu.gitgit config --global url.https://gitlab.com/webrtc-mirror/jsr-305.git.insteadOf https://chromium.googlesource.com/external/jsr-305.gitgit config --global url.https://gitlab.com/webrtc-mirror/jsoncpp.git.insteadOf https://chromium.googlesource.com/external/github.com/open-source-parsers/jsoncpp.gitgit config --global url.https://gitlab.com/webrtc-mirror/junit.git.insteadOf https://chromium.googlesource.com/external/junit.gitgit config --global url.https://gitlab.com/webrtc-mirror/fuzzer.git.insteadOf https://chromium.googlesource.com/chromium/llvm-project/compiler-rt/lib/fuzzer.gitgit config --global url.https://gitlab.com/webrtc-mirror/libjpeg_turbo.git.insteadOf https://chromium.googlesource.com/chromium/deps/libjpeg_turbo.gitgit config --global url.https://gitlab.com/webrtc-mirror/libsrtp.git.insteadOf https://chromium.googlesource.com/chromium/deps/libsrtp.gitgit config --global url.https://gitlab.com/webrtc-mirror/libvpx.git.insteadOf https://chromium.googlesource.com/webm/libvpx.gitgit config --global url.https://gitlab.com/webrtc-mirror/libyuv.git.insteadOf https://chromium.googlesource.com/libyuv/libyuv.gitgit config --global url.https://gitlab.com/webrtc-mirror/linux-syscall-support.git.insteadOf https://chromium.googlesource.com/linux-syscall-support.gitgit config --global url.https://gitlab.com/webrtc-mirror/mockito.git.insteadOf https://chromium.googlesource.com/external/mockito/mockito.gitgit config --global url.https://gitlab.com/webrtc-mirror/nasm.git.insteadOf https://chromium.googlesource.com/chromium/deps/nasm.gitgit config --global url.https://gitlab.com/webrtc-mirror/openh264.git.insteadOf https://chromium.googlesource.com/external/github.com/cisco/openh264git config --global url.https://gitlab.com/webrtc-mirror/requests.git.insteadOf https://chromium.googlesource.com/external/github.com/kennethreitz/requests.gitgit config --global url.https://gitlab.com/webrtc-mirror/robolectric.git.insteadOf https://chromium.googlesource.com/external/robolectric.gitgit config --global url.https://gitlab.com/webrtc-mirror/ub-uiautomator.git.insteadOf https://chromium.googlesource.com/chromium/third_party/ub-uiautomator.gitgit config --global url.https://gitlab.com/webrtc-mirror/usrsctp.git.insteadOf https://chromium.googlesource.com/external/github.com/sctplab/usrsctpgit config --global url.https://gitlab.com/webrtc-mirror/binaries.git.insteadOf https://chromium.googlesource.com/chromium/deps/yasm/binaries.gitgit config --global url.https://gitlab.com/webrtc-mirror/patched-yasm.git.insteadOf https://chromium.googlesource.com/chromium/deps/yasm/patched-yasm.gitgit config --global url.https://gitlab.com/webrtc-mirror/tools.git.insteadOf https://chromium.googlesource.com/chromium/src/toolsgit config --global url.https://gitlab.com/webrtc-mirror/client-py.git.insteadOf https://chromium.googlesource.com/infra/luci/client-py.gitgit config --global url.https://gitlab.com/webrtc-mirror/boringssl.git.insteadOf https://boringssl.googlesource.com/boringssl.git 安装depot_toolsexport WORKSPACE=$(pwd)git clone https://chromium.googlesource.com/chromium/tools/depot_tools.gitexport PATH=$WORKSPACE/depot_tools:$PATH 配置http和https代理// http和https代理服务，因为是代理外网服务，有可能出现间歇性的不稳定，如果不工作可以提issuse// 请不要滥用该http和https代理服务，后面会加上黑名单服务export http_proxy=http://39.105.13.136:8080export https_proxy=http://39.105.13.136:8080 同步WebRTCgclient config --name src https://chromium.googlesource.com/external/webrtc.gitgclient sync 编译WebRTCmac平台 cd src// 可以加入其它的编译参数gn gen out/mac --args=&#x27;is_debug=false target_cpu=&quot;x64&quot; rtc_include_tests=false rtc_build_tools=false rtc_build_examples=false&#x27;// mac_framework_objc 为framework， 可以为其它的targetninja -C out/mac mac_framework_objc iOS平台 cd srcpython tools_webrtc/ios/build_ios_libs.py --output-dir out/ios --arch arm64 --extra-gn-args rtc_include_tests=false rtc_build_tools=false rtc_build_examples=false Linux平台 cd src// 安装依赖bash build/install-build-deps.sh // 可以加入其它的编译参数gn gen out/linux --args=&#x27;is_debug=false target_cpu=&quot;x64&quot; rtc_include_tests=false rtc_build_tools=false rtc_build_examples=false&#x27;ninja -C out/linux Android 平台（须在linux平台上编译） # 添加安卓平台echo &quot;target_os = [ &#x27;android&#x27; ]&quot; &gt;&gt; .gclientgclient sync cd src// 安装android依赖./build/install-build-deps-android.shpython tools_webrtc/android/build_aar.py --build-dir out/android --arch armeabi-v7a --extra-gn-args rtc_include_tests=false rtc_build_tools=false rtc_build_examples=false Windows 平台 gn gen out/Win --args=&#x27;proprietary_codecs=true is_debug=false target_cpu=&quot;x86&quot; ffmpeg_branding=&quot;Chrome&quot; rtc_include_tests=false&#x27;ninja -C out/Win 清空http和https代理由于对http和https代理做了相应的白名单处理， 使用该http代理后访问其它的网站会被禁止， 在编译完WebRTC需要把http和https代理设置为空 export http_proxy=&#x27;&#x27;export https_proxy=&#x27;&#x27; 注意 为了加快下载和编译我们目前禁止掉了测试文件的下载， 所以在编译的时候请加上 rtc_include_tests=false 为了节省代理流量，我们对通过代理的域名进行了过滤，只允许WebRTC相关域名通过"},{"title":"Hexo的基本使用","path":"post/2602165680/","text":"1. 前言Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。即把用户的markdown文件，按照指定的主题解析成静态网页。 2. 安装hexo安装使用hexo之前需要先安装Node.js和Git，当已经安装了Node.js和npm(npm是node.js的包管理工具)，可以通过以下命令安装hexo $ npm install -g hexo-cli 可以通过以下命令查看主机中是否安装了node.js和npm $ node --version #检查是否安装了node.js$ npm --version #检查是否安装了npm 如下所示表示已经安装了node.js和npm root@***:~# node --versionv8.11.3root@***:~# npm --version6.7.0 3. 建站安装完Hexo之后，执行下列命令，Hexo将会在指定目录中新建所需要的文件，指定的目录即为Hexo的工作站 $ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成之后，指定目录中的情况如下 ├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 3.1. _config.yml网站的配置信息，您可以在此配置大部分的参数。 3.2. package.json应用程序的信息，以及需要安装的模块信息。 3.3. scaffolds模版文件夹。新建文章时，Hexo 会根据 scaffold 中的模板文件来建立新的文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。也就是说，通过hexo命令每新建一个文章，都会包含指定模板文件中的内容。 3.4. source资源文件夹是存放用户资源的地方，如markdown文章。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 注意：除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。 3.5. themes主题文件夹。Hexo 会根据主题来解析source目录中的markdown文件生成静态页面。官网主题详述 4. 写作可以执行下列命令来创建一篇新文章。 $ hexo new [layout] &lt;title&gt; 可以在命令中指定文章的布局（layout），不指定默认为 post，也可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。创建的新文章会自动加上指定布局对应的模板文件中的内容。 4.1. 布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局路径postsource/_postspagesourcedraftsource/_drafts 如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。 4.2. 模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： $ hexo new photo &quot;My Gallery&quot; 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量： 变量描述layout布局title标题date文件建立日期 4.3. Front-matterFront-matter是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： ---title: Hello Worlddate: 2013/7/13 20:46:25--- 注意：一般Front-matter使用的yaml语法，yaml语法需要注意空格，如title: Hello World冒号需要有一个空格，当然除YAML 外，你也可以使用 JSON 来编写 Front-matter。以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数描述默认值layout布局title标题date建立日期文件建立日updated更新日期文件更新日期comments开启文章的评论功能truetags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址 分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性而标签没有顺序和层次。 categories:- Diarytags:- PS3- Games WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法： categories:DiaryLife会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类. 4.4. 文章摘要设置文章摘要，我们只需在想显示为摘要的内容之后添 &lt;!-- more --&gt; 即可。像下面这样： ---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown--- 我是短小精悍的文章摘要(๑•̀ㅂ•́) ✧ &lt;!-- more --&gt; 紧接着文章摘要的正文内容 这样，&lt;!-- more --&gt; 之前、文档配置参数之后中的内容便会被渲染为站点中的文章摘要。 注意！文章摘要在文章详情页是正文中最前面的内容。 4.5. 资源引用写个博客，有时候会想添加个图片或者其他形式的资源等等。有以下两种方式进行解决： 使用绝对路径引用资源，在 Web 世界中就是资源的 URL使用相对路径引用资源对于使用相对路径引用资源的，我们可以使用 Hexo 提供的资源文件夹功能。 使用文本编辑器打开站点根目录下的 _ config.yml 文件，将 post_asset_folder 值设置为 true。 post_asset_folder: true修改之后会开启 Hexo 的文章资源文件管理功能。Hexo 将会在我们每一次通过 hexo new &lt;title&gt; 命令创建新文章时自动创建一个同名文件夹，于是我们便可以将文章所引用的相关资源放到这个同名文件夹下，然后通过相对路径引用。例如，你把一个 example.jpg 图片放在了这个同名文件夹中，使用相对路径的常规 markdown 语法 ![](./example.jpg)即可访问 。 5. 网站发布首先执行下列命令生成相应的静态网页，生成的静态网页以及相关资源都会在public目录下 $ hexo generate 5.1. 用hexo-serverhexo-server模块的主要命令如下，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。 $ hexo server 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下： $ hexo server -p 5000 但是个人认为此方式比较适合用于调试网站，并不适合长时间的网站服务器，同时为了让这个命令在后台长时间运行，需要编写相应的脚本。 5.2. 部署到Git上这个暂时没有尝试过，但是网络上很多都是关于部署到Git上的，可以自行谷歌或百度。 5.3. 部署到Apache或者Nginx上通过hexo g命令生成的都是静态网页，可以把生成的public目录中的文件，全都拷贝到网站根目录，然后启动apache或者nginx服务。 6. 其他基础命令6.1. 清除缓存文件为了避免不必要的错误，在生成静态文件前，强烈建议先运行以下命令： $ hexo clean 上述命令会清除本地站点文件夹下的缓存文件（db.json）和已有的静态文件（public）。 简写如下$ hexo cl $ hexo d -g $ hexo server"},{"title":"面试题（一）","path":"post/950528940/","text":"谈谈RuntimeOC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数平时编写的OC代码，底层都是转换成了Runtime API进行调用 利用如time我们可以做很多事情 如 利用关联对象（AssociatedObject）给分类添加属性 遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档） 交换方法实现（交换系统的方法） 利用消息转发机制解决方法找不到的异常问题OC中方法的调用都是转化为objc_msgSend函数的调用objc_msgSend函数可以分为三个阶段 第一个阶段是：消息发送阶段首先判断消息的接受者是否存在 如果不存在则直接返回如果存在则 从自己类的方法缓存列表中查找该方法，如果存在则执行 如果不存在则去自己类的方法列表中查找，如果存在则缓存到自己类的方法缓存列表中 然后在执行，如果不存在则去父类的方法缓存列表中查找，如果存在则缓存到自己类的方法缓存列表中 然后执行，如果不存在 则去父父类的方法列表中查找，如果存在 则缓存到自己类的方法缓存列表中， 如果不存在则进入第二不 方法动态解析阶段 第二阶段是：方法动态解析阶段首先判断方法是否动态解析过，如果之前已经有过动态解析 则直接进入第一步消息发送阶段如果没有过动态解析则调用+resolveInstanceMethod：或则+resoveClassMethod：方法来动态解析 然后标记为已经动态解析 最后重新走“消息发送”的流程在此阶段 我们可以添加一个新的方法来代替原来的方法 如果在此阶段不做任何处理 则直接进入第三步 消息转发阶段 第三阶段是：消息转发阶段 首先调用forwardingTargetForSelector:方法 在此方法中：如果返回值不为空 则直接给返回值转发消息如果返回值为空否则进入第2步 调用方法签名函数 调用methodSignatureForSelector:方法（方法签名函数）在此方法中：如果返回值为空 则直接调用 调用doesNotRecognizeSelector:方法 然后程序报错：unrecognized selector sent to instance 经典错误如果返回值不为空 则直接进入第3步 调用 forwardInvocation方法 forwardInvocation：方法开发人员可以在此方法中处理调用的方法 谈谈Runloop顾名思义就是运行循环，在程序运行过程中循环做一些事情 保持程序的持续运行 处理App中的各种事件（比如触摸事件、定时器事件等） 节省CPU资源，提高程序性能：该做事时做事，该休息时休息 runloop与线程之间的关系 每条线程都有唯一的一个与之对应的RunLoop对象 RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value 线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建（[NSRunLoop currentRunLoop]） RunLoop会在线程结束时销毁 主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop 获取runloop对象的方法[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象CFRunLoopGetMain(); // 获得主线程的RunLoop对象 你做了什么工作使崩溃率下降的 （使用什么工具定位崩溃，崩溃的补救措施）答：线上项目中集成第三方bug收集工具 bugly 然后配置好符号表（dSYM），app每次崩溃bugly后台都会有相应的崩溃信息，而且能够具体的某一行，根据崩溃信息查漏补缺。开发过程中根据Xcode设置全局断点定位崩溃某一行。测试过程中可以根据bugly后台查看崩溃信息，也可以使用Xcode查看手机里面的log信息来分析crash信息。 使用什么方式使子线程永驻开启子线程的runloop https 中间人攻击（是怎样攻击的）HTTPS 中间人攻击。也就是通讯双方中插入一个中间人，通讯双方的对方已经变成中间人了，而不是原本的对方。 HTTPS 协议之所以是安全的是因为 HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现。但其实，HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。 HTTPS的整体过程分为证书验证和数据传输阶段 ① 证书验证阶段 客户端发起 HTTPS 请求 服务端返回 HTTPS 证书 客户端验证证书是否合法，如果不合法则提示告警 ② 数据传输阶段 当证书验证合法后，客户端在本地生成随机数 通过公钥加密随机数，并把加密后的随机数传输到服务端 服务端通过私钥对随机数进行解密 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输 为什么数据传输是用对称加密？首先，非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；另外，在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。 为什么需要 CA 认证机构颁发证书？HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 HTTPS 协议主要解决的便是网络传输的安全性问题。首先我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的“中间人攻击”问题。“中间人攻击”的具体过程如下： 过程原理： 客户端请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器 中间人服务器返回中间人自己的证书 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密 中间人以客户端的请求内容再向正规网站发起请求 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据 中间人凭借与正规网站建立的对称加密算法对内容进行解密 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。Q: HTTPS 为什么安全？A: 因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性。 Q: HTTPS 的传输过程是怎样的？A: 客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密。Q: 为什么需要证书？A: 防止”中间人“攻击，同时可以为网站提供身份证明。 Q: 使用 HTTPS 会被抓包吗？A: 会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。 KVC 原理 KVC的全称是Key-Value Coding、俗称“键值编码”、可以通过一个key来访问某一个属性。 常见的API有四种setValue: forKeysetValue: forKeyPathvalueForKey:valueForKeyPathforKey 和 forKeyPath 主要区别是路径区别 KVO实现原理KVO的原理： 当实例对象 进行KVO观察时候，会利用RuntimeAPI动态生成一个子类，然后将对象的isa指向新生成的子类 KVO本质上是监听属性的setter方法，只要被观察对象有成员变量和对应的set方法，调用Foundation的_NSSetValueAndNotify函数这个函数内部会执行 willChangeVlaueForKey函数、父类的setter方法 和didChangeVlaueForKey函数 子类会重写父类的set、class、dealloc方法 当观察对象移除所有的监听后，会将观察对象的isa指向原来的类 当观察对象的监听全部移除后，动态生成的类不会注销，而是留在下次观察时候再使用，避免反复创建中间子类 为什么ui在主线程刷新UI刷新在主线程主要有两个原因第一：安全因为UIKit框架不是线程安全的，当多个线程同时操作UI的时候，抢夺资源，导致崩溃，UI异常等问题。 第二：用户体验iOS中只有主线程才能立即刷新UI。在子线程中是不能够更新UI，我们看到的子线程能够更新UI的原因是，等到子线程执行完毕，自动进入了主线程去执行子线程中更新UI的代码。由于子线程执行时间非常短暂，让我们误以为子线程可以更新UI。如果子线程一直在运行，则无法更新UI，因为没有办法进入主线程。 block有几种，底层实现，以及如何持有外部变量的block是封装了函数调用以及函数调用环境的OC对象block 有三种类型分别如下__NSGlobalBlock__NSStackBlock__NSMallocBlock只要没有访问 auto的变量 都是 NSGlobalBlock 访问了auto变量 但是没有调用 copy 都是 NSStackBlock 即访问了auto变量又调用了copy 则是 NSMallocBlock 注意：__NSGlobalBlock__即使调用了copy 它还是 NSGlobalBlock__NSStackBlock__调用了 copy 它就变成了 NSMallocBlockNSMallocBlock 调用了copy 只是使引用计数增加 其类型还是 NSMallocBlock"},{"title":"个人Blog使用","path":"post/1750059094/","text":"准备工具1.安装node.js2.安装hexo3.安装git（选择性安装，因为hexo有插件可以直接上传Github）4.一个Github账号用于创建库 需具备基础1.html2.css3.markdown（主要写文章的标记语言，编写方便） 创建一个Github库在Github中创建一个库，其中Repository name将会影响到后续网页的上传，请慎重填写。 创建完库后的https链接记下来，后续上传网页将会用到 安装node.js进入https://nodejs.org/ LTS:长期服务，较为稳定Current:最新版本建议下载LTS版本，搭建网站以稳为主。 可以选择直接下载安装包下载，也可以用指令搭配其他环境下载https://nodejs.org/zh-tw/download/package-manager/ 安装完后，检查node.js版本验证是否成功安装 npm -v #检查npm版本号node -v #检查node.js版本号 安装HexoHexo必须在具备node.js的环境中运行，所以必须执行上一步在命令行中执行 npm install hexo-cli -g #安装Hexo本体 创建第一个网页初始化Hexo用于创建第一个页面 hexo init #初始化Hexo hexo init的后面也可以加一个文件夹名字用于创建一个新的空文件夹，比如在后面加一个blog，如果文件夹不是空的，hexo将初始化失败。 hexo init blog #在blog文件夹初始化Hexo 写第一篇文章hexo new &lt;tittle&gt; #创建一个新页面，&lt; &gt;内为文章标题 如果你的主题有默认布局，则可以加上layout生成默认布局的页面 hexo new [layout] &lt;title&gt; 测试和编译hexo s #启用服务，http://localhost:4000/ 为默认地址 上传网页在不使用git的情况下，单纯靠Hexo上传网页，需要先安装Hexo内的一个插件 npm install hexo-deployer-git --save #安装hexo-deployer-git 安装完成后需到hexo的_config.yml配置文件进行GitHub库的设定 # Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: &#x27;git&#x27; #如果是上传到git，type类型填git repo: &#x27;https://github.com/username/blog.git&#x27; #这边填写的就是你创建完库后的http链接，直接复制粘贴即可。username填你的名字，blog是你的库，如果你的库就是你的名字则不需要username后面的内容，但最后都加.git brach: &#x27;gh-pages&#x27; #这边是你库的分支，选择你想上传的就好，一般填gh-pages 清除本地文件 hexo cl #清除本地文件 编译生成静态网页文件 hexo g #编译生成静态网页文件 将编译完成的静态文件上传至Github hexo d #上传至Github,第一次上传会要求登入账号 之后就完成啦～你的网站已经可以在Github上正常使用了～ 推荐使用软件1.TyporaMarkdown语言的编辑器，可以很轻易的编写内容 2.Visual Studio Code微软出品的编辑器，前端必备"}]